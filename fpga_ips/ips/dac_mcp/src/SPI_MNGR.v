// -------------------------------------------------------------
// 
// File Name: C:\Users\angro\Desktop\hil\dac\SPI_DAC\int2bin_sdi\SPI_MNGR.v
// Created: 2024-11-01 19:07:18
// 
// Generated by MATLAB 24.2, HDL Coder 24.2, and Simulink 24.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: SPI_MNGR
// Source Path: int2bin_sdi/SPI_DAC/SPI_MNGR
// Hierarchy Level: 1
// Model version: 3.41
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module SPI_MNGR
          (clk,
           rst,
           numer_vx,
           v3_2,
           v3_1,
           v1_2,
           v2_1,
           v2_2,
           v1_1,
           SDI,
           SCK,
           nCS1,
           nCS2,
           nCS3);

  // Default encoded enumeration values for type state_type_is_SPI_MNGR
  parameter state_type_is_SPI_MNGR_IN_NOP = 4'd0, state_type_is_SPI_MNGR_IN_NOP1 = 4'd1, state_type_is_SPI_MNGR_IN_off = 4'd2, state_type_is_SPI_MNGR_IN_sender_at_SCK = 4'd3, state_type_is_SPI_MNGR_IN_sender_at_SCK1 = 4'd4, state_type_is_SPI_MNGR_IN_sender_pre_SCK = 4'd5, state_type_is_SPI_MNGR_IN_toBsend_CH_A = 4'd6, state_type_is_SPI_MNGR_IN_toBsend_CH_B = 4'd7, state_type_is_SPI_MNGR_IN_toBsend_v1_1 = 4'd8, state_type_is_SPI_MNGR_IN_toBsend_v1_2 = 4'd9, state_type_is_SPI_MNGR_IN_toBsend_v2_1 = 4'd10, state_type_is_SPI_MNGR_IN_toBsend_v2_2 = 4'd11, state_type_is_SPI_MNGR_IN_toBsend_v3_1 = 4'd12, state_type_is_SPI_MNGR_IN_toBsend_v3_2 = 4'd13;

  input   clk;
  input   rst;
  input   [7:0] numer_vx;  // uint8
  input   [7:0] v3_2;  // uint8
  input   [7:0] v3_1;  // uint8
  input   [7:0] v1_2;  // uint8
  input   [7:0] v2_1;  // uint8
  input   [7:0] v2_2;  // uint8
  input   [7:0] v1_1;  // uint8
  output  SDI;
  output  SCK;
  output  nCS1;
  output  nCS2;
  output  nCS3;


  reg [7:0] cnt;  // uint8
  reg [7:0] cnt_clk;  // uint8
  reg  [15:0] payload;  // boolean [16]
  reg [7:0] selector;  // uint8
  reg [7:0] cont_bits [0:7];  // uint8 [8]
  reg [3:0] is_SPI_MNGR;  // uint8
  reg  SDI_reg;
  reg  SCK_reg;
  reg  nCS1_reg;
  reg  nCS2_reg;
  reg  nCS3_reg;
  reg [7:0] cnt_next;  // uint8
  reg [7:0] cnt_clk_next;  // uint8
  reg  [15:0] payload_next;  // boolean [16]
  reg [7:0] selector_next;  // uint8
  reg [7:0] cont_bits_next [0:7];  // uint8 [8]
  reg [3:0] is_SPI_MNGR_next;  // enum type state_type_is_SPI_MNGR (14 enums)
  reg  SDI_reg_next;
  reg  SCK_reg_next;
  reg  nCS1_reg_next;
  reg  nCS2_reg_next;
  reg  nCS3_reg_next;
  reg  d_sf_internal_predicateOutput;
  reg  e_sf_internal_predicateOutput;
  reg  f_sf_internal_predicateOutput;
  reg  d_sf_internal_predicateOutput_0;
  reg  e_sf_internal_predicateOutput_0;
  reg  f_sf_internal_predicateOutput_0;
  reg signed [7:0] b_cont_bits [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_0 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_1 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_2 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_3 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_4 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_5 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_6 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_7 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_8 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_9 [0:7];  // uint8 [8]
  reg signed [7:0] b_cont_bits_10 [0:7];  // uint8 [8]
  reg [7:0] tmp;  // uint8
  reg signed [31:0] j;  // int32
  reg [7:0] tmp_0;  // uint8
  reg signed [31:0] j_0;  // int32
  reg [7:0] tmp_1;  // uint8
  reg signed [31:0] j_1;  // int32
  reg [7:0] tmp_2;  // uint8
  reg signed [31:0] j_2;  // int32
  reg [7:0] tmp_3;  // uint8
  reg signed [31:0] j_3;  // int32
  reg [7:0] tmp_4;  // uint8
  reg signed [31:0] j_4;  // int32
  reg [7:0] tmp_5;  // uint8
  reg signed [31:0] j_5;  // int32
  reg [7:0] tmp_6;  // uint8
  reg signed [31:0] j_6;  // int32
  reg [7:0] tmp_7;  // uint8
  reg signed [31:0] j_7;  // int32
  reg [7:0] tmp_8;  // uint8
  reg signed [31:0] j_8;  // int32
  reg [7:0] tmp_9;  // uint8
  reg signed [31:0] j_9;  // int32
  reg [7:0] tmp_10;  // uint8
  reg signed [31:0] j_10;  // int32
  reg signed [31:0] bm1;  // int32
  reg signed [31:0] bm1_0;  // int32
  reg signed [31:0] bm1_1;  // int32
  reg signed [31:0] bm1_2;  // int32
  reg signed [31:0] bm1_3;  // int32
  reg signed [31:0] bm1_4;  // int32
  reg signed [31:0] bm1_5;  // int32
  reg signed [31:0] bm1_6;  // int32
  reg signed [31:0] bm1_7;  // int32
  reg signed [31:0] bm1_8;  // int32
  reg signed [31:0] bm1_9;  // int32
  reg signed [31:0] bm1_10;  // int32
  reg  guard1;
  reg  guard2;
  reg  guard3;
  reg  guard4;
  reg  guard5;
  reg  guard6;
  reg  guard7;
  reg  guard8;
  reg  guard9;
  reg  guard10;
  reg  guard11;
  reg  guard12;
  reg  guard13;
  reg  guard14;
  reg  guard15;
  reg  guard16;
  reg  guard17;
  reg  guard18;
  reg  guard19;
  reg [7:0] cnt_temp;  // uint8
  reg [7:0] selector_temp;  // uint8
  reg signed [31:0] t_0;  // int32
  reg signed [31:0] t_1;  // int32
  reg signed [31:0] t_2;  // int32
  reg signed [31:0] t_3;  // int32
  reg signed [31:0] t_4;  // int32
  reg signed [31:0] t_5;  // int32
  reg signed [31:0] t_6;  // int32
  reg signed [31:0] t_7;  // int32
  reg signed [31:0] t_8;  // int32
  reg signed [31:0] t_9;  // int32
  reg signed [31:0] t_10;  // int32
  reg signed [31:0] t_11;  // int32
  reg signed [31:0] t_12;  // int32
  reg signed [31:0] t_13;  // int32
  reg signed [31:0] t_14;  // int32
  reg signed [31:0] t_15;  // int32
  reg signed [31:0] t_16;  // int32
  reg signed [31:0] t_17;  // int32
  reg signed [31:0] t_18;  // int32
  reg signed [31:0] t_19;  // int32
  reg [8:0] add_temp;  // ufix9
  reg [8:0] add_temp_0;  // ufix9
  reg [8:0] add_temp_1;  // ufix9
  reg [8:0] add_temp_2;  // ufix9
  reg [8:0] add_temp_3;  // ufix9
  reg [8:0] add_temp_4;  // ufix9
  reg [8:0] add_temp_5;  // ufix9
  reg  [7:0] t_20;  // boolean [8]
  reg  [7:0] t_21;  // boolean [8]
  reg  [7:0] t_22;  // boolean [8]
  reg  [7:0] t_23;  // boolean [8]
  reg  [7:0] t_24;  // boolean [8]
  reg  [7:0] t_25;  // boolean [8]
  reg  [7:0] t_26;  // boolean [8]
  reg  [7:0] t_27;  // boolean [8]
  reg  [7:0] t_28;  // boolean [8]
  reg  [7:0] t_29;  // boolean [8]
  reg  [7:0] t_30;  // boolean [8]
  reg  [7:0] t_31;  // boolean [8]
  reg [8:0] t_32;  // ufix9
  reg [8:0] t_33;  // ufix9
  reg [8:0] t_34;  // ufix9
  reg [8:0] t_35;  // ufix9
  reg [8:0] t_36;  // ufix9
  reg [8:0] t_37;  // ufix9
  reg [8:0] t_38;  // ufix9
  reg signed [31:0] t_0_0;  // int32
  reg signed [31:0] t_1_0;  // int32
  reg signed [31:0] t_2_0;  // int32
  reg signed [31:0] t_3_0;  // int32


  always @(posedge clk)
    begin : SPI_MNGR_1_process
      if (rst == 1'b1) begin
        cnt <= 8'd1;
        cnt_clk <= 8'd1;

        for(t_2_0 = 1'b0; t_2_0 <= 4'b1111; t_2_0 = t_2_0 + 1'b1) begin
          payload[t_2_0] <= 1'b0;
        end

        selector <= 8'd1;

        for(t_3_0 = 1'b0; t_3_0 <= 3'b111; t_3_0 = t_3_0 + 1'b1) begin
          cont_bits[t_3_0] <= 8'd0;
        end

        //Entry: SPI_DAC/SPI_MNGR
        //Entry Internal: SPI_DAC/SPI_MNGR
        //Transition
        is_SPI_MNGR <= state_type_is_SPI_MNGR_IN_off;
        //Entry 'off'
        SDI_reg <= 1'b0;
        SCK_reg <= 1'b0;
        nCS1_reg <= 1'b1;
        nCS2_reg <= 1'b1;
        nCS3_reg <= 1'b1;
      end
      else begin
        cnt <= cnt_next;
        cnt_clk <= cnt_clk_next;

        for(t_0_0 = 1'b0; t_0_0 <= 4'b1111; t_0_0 = t_0_0 + 1'b1) begin
          payload[t_0_0] <= payload_next[t_0_0];
        end

        selector <= selector_next;

        for(t_1_0 = 1'b0; t_1_0 <= 3'b111; t_1_0 = t_1_0 + 1'b1) begin
          cont_bits[t_1_0] <= cont_bits_next[t_1_0];
        end

        is_SPI_MNGR <= is_SPI_MNGR_next;
        SDI_reg <= SDI_reg_next;
        SCK_reg <= SCK_reg_next;
        nCS1_reg <= nCS1_reg_next;
        nCS2_reg <= nCS2_reg_next;
        nCS3_reg <= nCS3_reg_next;
      end
    end

  always @* begin
    j = 32'sd0;
    j_0 = 32'sd0;
    j_1 = 32'sd0;
    j_2 = 32'sd0;
    j_3 = 32'sd0;
    j_4 = 32'sd0;
    j_5 = 32'sd0;
    j_6 = 32'sd0;
    j_7 = 32'sd0;
    j_8 = 32'sd0;
    j_9 = 32'sd0;
    j_10 = 32'sd0;
    d_sf_internal_predicateOutput_0 = 1'b0;
    d_sf_internal_predicateOutput = 1'b0;
    e_sf_internal_predicateOutput_0 = 1'b0;
    e_sf_internal_predicateOutput = 1'b0;
    f_sf_internal_predicateOutput_0 = 1'b0;
    f_sf_internal_predicateOutput = 1'b0;
    add_temp = 9'b000000000;
    add_temp_0 = 9'b000000000;
    add_temp_1 = 9'b000000000;
    add_temp_2 = 9'b000000000;
    add_temp_3 = 9'b000000000;
    add_temp_4 = 9'b000000000;
    add_temp_5 = 9'b000000000;
    tmp_8 = 8'd0;
    tmp_6 = 8'd0;
    tmp_4 = 8'd0;
    tmp_2 = 8'd0;
    tmp_0 = 8'd0;
    tmp = 8'd0;
    tmp_10 = 8'd0;
    tmp_9 = 8'd0;
    tmp_7 = 8'd0;
    tmp_5 = 8'd0;
    tmp_3 = 8'd0;
    tmp_1 = 8'd0;
    t_32 = 9'b000000000;
    t_33 = 9'b000000000;
    t_34 = 9'b000000000;
    t_35 = 9'b000000000;
    t_36 = 9'b000000000;
    t_37 = 9'b000000000;
    t_38 = 9'b000000000;
    cnt_temp = cnt;
    selector_temp = selector;
    SDI_reg_next = SDI_reg;
    SCK_reg_next = SCK_reg;
    nCS1_reg_next = nCS1_reg;
    nCS2_reg_next = nCS2_reg;
    nCS3_reg_next = nCS3_reg;
    cnt_clk_next = cnt_clk;

    for(t_0 = 1'b0; t_0 <= 4'b1111; t_0 = t_0 + 1'b1) begin
      payload_next[t_0] = payload[t_0];
    end
    for(t_1 = 1'b0; t_1 <= 3'b111; t_1 = t_1 + 1'b1) begin
      cont_bits_next[t_1] = cont_bits[t_1];
    end

    is_SPI_MNGR_next = is_SPI_MNGR;
    //Gateway: SPI_DAC/SPI_MNGR
    //During: SPI_DAC/SPI_MNGR
    guard1 = 1'b0;
    guard2 = 1'b0;
    guard3 = 1'b0;
    guard4 = 1'b0;
    guard5 = 1'b0;
    guard6 = 1'b0;
    guard7 = 1'b0;
    guard8 = 1'b0;
    guard9 = 1'b0;
    guard10 = 1'b0;
    guard11 = 1'b0;
    guard12 = 1'b0;
    guard13 = 1'b0;
    guard14 = 1'b0;
    guard15 = 1'b0;
    guard16 = 1'b0;
    guard17 = 1'b0;
    guard18 = 1'b0;
    guard19 = 1'b0;
    case ( is_SPI_MNGR)
      state_type_is_SPI_MNGR_IN_NOP :
        begin
          //During 'NOP'
          //Transition
          if (cnt_clk > 8'b00000001) begin
            //Transition
            cnt_clk_next = 8'd1;
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_at_SCK1;
            //Entry 'sender_at_SCK1'
            SCK_reg_next = 1'b1;
          end
          else if (cnt_clk <= 8'b00000001) begin
            //Transition
            t_38 = {1'b0, cnt_clk};
            add_temp_2 = t_38 + 9'b000000001;
            if (add_temp_2[8] != 1'b0) begin
              cnt_clk_next = 8'b11111111;
            end
            else begin
              cnt_clk_next = add_temp_2[7:0];
            end
            //Transition
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_NOP;
            //Entry 'NOP'
            SCK_reg_next = 1'b0;
            nCS1_reg_next = 1'b1;
            nCS2_reg_next = 1'b1;
            nCS3_reg_next = 1'b1;
          end
          else begin
            SCK_reg_next = 1'b0;
            nCS1_reg_next = 1'b1;
            nCS2_reg_next = 1'b1;
            nCS3_reg_next = 1'b1;
          end
        end
      state_type_is_SPI_MNGR_IN_NOP1 :
        begin
          //During 'NOP1'
          //Transition
          if (cnt_clk <= 8'b00000100) begin
            //Transition
            t_36 = {1'b0, cnt_clk};
            add_temp = t_36 + 9'b000000001;
            if (add_temp[8] != 1'b0) begin
              cnt_clk_next = 8'b11111111;
            end
            else begin
              cnt_clk_next = add_temp[7:0];
            end
            //Transition
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_NOP1;
          end
          else if (cnt_clk > 8'b00000100) begin
            //Transition
            cnt_clk_next = 8'd1;
            //Transition
            //Transition
            //Transition
            t_37 = {1'b0, selector};
            add_temp_4 = t_37 + 9'b000000001;
            if (add_temp_4[8] != 1'b0) begin
              selector_temp = 8'b11111111;
            end
            else begin
              selector_temp = add_temp_4[7:0];
            end
            //Transition
            if (selector_temp > numer_vx) begin
              //Transition
              //Transition
              selector_temp = 8'd1;
              //Transition
              //Transition
              //Transition
              nCS1_reg_next = 1'b0;
              nCS2_reg_next = 1'b1;
              nCS3_reg_next = 1'b1;
              //Transition
              guard1 = 1'b1;
            end
            else begin
              guard18 = 1'b1;
            end
          end
        end
      state_type_is_SPI_MNGR_IN_off :
        begin
          //During 'off'
          if (numer_vx > 8'b00000000) begin
            //Transition
            //Transition
            if (selector > numer_vx) begin
              //Transition
              //Transition
              selector_temp = 8'd1;
              //Transition
              //Transition
              //Transition
              nCS1_reg_next = 1'b0;
              nCS2_reg_next = 1'b1;
              nCS3_reg_next = 1'b1;
              //Transition
              guard8 = 1'b1;
            end
            else begin
              guard19 = 1'b1;
            end
          end
          else begin
            guard7 = 1'b1;
          end
        end
      state_type_is_SPI_MNGR_IN_sender_at_SCK :
        begin
          //During 'sender_at_SCK'
          //Transition
          if (cnt_clk > 8'b00000010) begin
            //Transition
            cnt_clk_next = 8'd1;
            if (cnt >= 8'b00010000) begin
              //Transition
              cnt_temp = 8'd1;
              is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_NOP;
              //Entry 'NOP'
              SCK_reg_next = 1'b0;
              nCS1_reg_next = 1'b1;
              nCS2_reg_next = 1'b1;
              nCS3_reg_next = 1'b1;
            end
            else begin
              //Transition
              //Transition
              //Transition
              t_34 = {1'b0, cnt};
              add_temp_5 = t_34 + 9'b000000001;
              if (add_temp_5[8] != 1'b0) begin
                cnt_temp = 8'b11111111;
              end
              else begin
                cnt_temp = add_temp_5[7:0];
              end
              is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_pre_SCK;
              //Entry 'sender_pre_SCK'
              SDI_reg_next = payload[cnt_temp - 8'b00000001];
              SCK_reg_next = 1'b0;
            end
          end
          else if (cnt_clk <= 8'b00000010) begin
            //Transition
            t_35 = {1'b0, cnt_clk};
            add_temp_3 = t_35 + 9'b000000001;
            if (add_temp_3[8] != 1'b0) begin
              cnt_clk_next = 8'b11111111;
            end
            else begin
              cnt_clk_next = add_temp_3[7:0];
            end
            //Transition
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_at_SCK;
            //Entry 'sender_at_SCK'
            SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
            SCK_reg_next = 1'b1;
          end
          else begin
            SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
            SCK_reg_next = 1'b1;
          end
        end
      state_type_is_SPI_MNGR_IN_sender_at_SCK1 :
        begin
          //During 'sender_at_SCK1'
          //Transition
          if (cnt_clk <= 8'b00000010) begin
            //Transition
            t_33 = {1'b0, cnt_clk};
            add_temp_0 = t_33 + 9'b000000001;
            if (add_temp_0[8] != 1'b0) begin
              cnt_clk_next = 8'b11111111;
            end
            else begin
              cnt_clk_next = add_temp_0[7:0];
            end
            //Transition
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_at_SCK1;
            //Entry 'sender_at_SCK1'
            SCK_reg_next = 1'b1;
          end
          else if (cnt_clk > 8'b00000010) begin
            //Transition
            cnt_clk_next = 8'd1;
            //Transition
            SCK_reg_next = 1'b0;
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_NOP1;
          end
          else begin
            SCK_reg_next = 1'b1;
          end
        end
      state_type_is_SPI_MNGR_IN_sender_pre_SCK :
        begin
          //During 'sender_pre_SCK'
          //Transition
          if (cnt_clk <= 8'b00000010) begin
            //Transition
            t_32 = {1'b0, cnt_clk};
            add_temp_1 = t_32 + 9'b000000001;
            if (add_temp_1[8] != 1'b0) begin
              cnt_clk_next = 8'b11111111;
            end
            else begin
              cnt_clk_next = add_temp_1[7:0];
            end
            //Transition
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_pre_SCK;
            //Entry 'sender_pre_SCK'
            SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
            SCK_reg_next = 1'b0;
          end
          else if (cnt_clk > 8'b00000010) begin
            //Transition
            cnt_clk_next = 8'd1;
            is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_at_SCK;
            //Entry 'sender_at_SCK'
            SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
            SCK_reg_next = 1'b1;
          end
          else begin
            SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
            SCK_reg_next = 1'b0;
          end
        end
      state_type_is_SPI_MNGR_IN_toBsend_CH_A :
        begin
          //During 'toBsend_CH_A'
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_pre_SCK;
          //Entry 'sender_pre_SCK'
          SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
          SCK_reg_next = 1'b0;
        end
      state_type_is_SPI_MNGR_IN_toBsend_CH_B :
        begin
          //During 'toBsend_CH_B'
          //Transition
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_sender_pre_SCK;
          //Entry 'sender_pre_SCK'
          SDI_reg_next = payload[$signed({1'b0, cnt}) - 9'sb000000001];
          SCK_reg_next = 1'b0;
        end
      state_type_is_SPI_MNGR_IN_toBsend_v1_1 :
        begin
          //During 'toBsend_v1_1'
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_A;
          //Entry 'toBsend_CH_A'
          payload_next[1'b0] = 1'b0;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_2 = 1'b0; t_2 <= 3'b111; t_2 = t_2 + 1'b1) begin
            payload_next[t_2 + $signed({1'b0, 4'b0100})] = cont_bits[t_2] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
      state_type_is_SPI_MNGR_IN_toBsend_v1_2 :
        begin
          //During 'toBsend_v1_2'
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_B;
          //Entry 'toBsend_CH_B'
          payload_next[1'b0] = 1'b1;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_3 = 1'b0; t_3 <= 3'b111; t_3 = t_3 + 1'b1) begin
            payload_next[t_3 + $signed({1'b0, 4'b0100})] = cont_bits[t_3] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
      state_type_is_SPI_MNGR_IN_toBsend_v2_1 :
        begin
          //During 'toBsend_v2_1'
          //Transition
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_A;
          //Entry 'toBsend_CH_A'
          payload_next[1'b0] = 1'b0;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_4 = 1'b0; t_4 <= 3'b111; t_4 = t_4 + 1'b1) begin
            payload_next[t_4 + $signed({1'b0, 4'b0100})] = cont_bits[t_4] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
      state_type_is_SPI_MNGR_IN_toBsend_v2_2 :
        begin
          //During 'toBsend_v2_2'
          //Transition
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_B;
          //Entry 'toBsend_CH_B'
          payload_next[1'b0] = 1'b1;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_5 = 1'b0; t_5 <= 3'b111; t_5 = t_5 + 1'b1) begin
            payload_next[t_5 + $signed({1'b0, 4'b0100})] = cont_bits[t_5] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
      state_type_is_SPI_MNGR_IN_toBsend_v3_1 :
        begin
          //During 'toBsend_v3_1'
          //Transition
          //Transition
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_A;
          //Entry 'toBsend_CH_A'
          payload_next[1'b0] = 1'b0;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_6 = 1'b0; t_6 <= 3'b111; t_6 = t_6 + 1'b1) begin
            payload_next[t_6 + $signed({1'b0, 4'b0100})] = cont_bits[t_6] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
      default :
        begin
          //case IN_toBsend_v3_2:
          //During 'toBsend_v3_2'
          //Transition
          //Transition
          //Transition
          //Transition
          is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_CH_B;
          //Entry 'toBsend_CH_B'
          payload_next[1'b0] = 1'b1;
          payload_next[1'b1] = 1'b1;
          payload_next[2] = 1'b1;
          payload_next[3] = 1'b1;

          for(t_7 = 1'b0; t_7 <= 3'b111; t_7 = t_7 + 1'b1) begin
            payload_next[t_7 + $signed({1'b0, 4'b0100})] = cont_bits[t_7] != 8'b00000000;
          end

          payload_next[12] = 1'b1;
          payload_next[13] = 1'b1;
          payload_next[14] = 1'b1;
          payload_next[15] = 1'b1;
        end
    endcase
    if (guard19) begin
      //Transition
      //Transition
      d_sf_internal_predicateOutput_0 = (selector_temp == 8'b00000001) || (selector_temp == 8'b00000010);
      if (d_sf_internal_predicateOutput_0) begin
        //Transition
        nCS1_reg_next = 1'b0;
        nCS2_reg_next = 1'b1;
        nCS3_reg_next = 1'b1;
        if (selector_temp == 8'b00000001) begin
          //Transition
          guard8 = 1'b1;
        end
        else if (selector_temp == 8'b00000010) begin
          //Transition
          guard9 = 1'b1;
        end
        else begin
          guard17 = 1'b1;
        end
      end
      else begin
        guard17 = 1'b1;
      end
    end
    if (guard18) begin
      //Transition
      //Transition
      d_sf_internal_predicateOutput = (selector_temp == 8'b00000001) || (selector_temp == 8'b00000010);
      if (d_sf_internal_predicateOutput) begin
        //Transition
        nCS1_reg_next = 1'b0;
        nCS2_reg_next = 1'b1;
        nCS3_reg_next = 1'b1;
        if (selector_temp == 8'b00000001) begin
          //Transition
          guard1 = 1'b1;
        end
        else if (selector_temp == 8'b00000010) begin
          //Transition
          guard2 = 1'b1;
        end
        else begin
          guard16 = 1'b1;
        end
      end
      else begin
        guard16 = 1'b1;
      end
    end
    if (guard17) begin
      e_sf_internal_predicateOutput_0 = (selector_temp == 8'b00000011) || (selector_temp == 8'b00000100);
      if (e_sf_internal_predicateOutput_0) begin
        //Transition
        nCS1_reg_next = 1'b1;
        nCS2_reg_next = 1'b0;
        nCS3_reg_next = 1'b1;
        //Transition
        if (selector_temp == 8'b00000011) begin
          //Transition
          guard10 = 1'b1;
        end
        else if (selector_temp == 8'b00000100) begin
          //Transition
          guard11 = 1'b1;
        end
        else begin
          guard15 = 1'b1;
        end
      end
      else begin
        guard15 = 1'b1;
      end
    end
    if (guard16) begin
      e_sf_internal_predicateOutput = (selector_temp == 8'b00000011) || (selector_temp == 8'b00000100);
      if (e_sf_internal_predicateOutput) begin
        //Transition
        nCS1_reg_next = 1'b1;
        nCS2_reg_next = 1'b0;
        nCS3_reg_next = 1'b1;
        //Transition
        if (selector_temp == 8'b00000011) begin
          //Transition
          guard3 = 1'b1;
        end
        else if (selector_temp == 8'b00000100) begin
          //Transition
          guard4 = 1'b1;
        end
        else begin
          guard14 = 1'b1;
        end
      end
      else begin
        guard14 = 1'b1;
      end
    end
    if (guard15) begin
      f_sf_internal_predicateOutput_0 = (selector_temp == 8'b00000101) || (selector_temp == 8'b00000110);
      if (f_sf_internal_predicateOutput_0) begin
        //Transition
        nCS1_reg_next = 1'b1;
        nCS2_reg_next = 1'b1;
        nCS3_reg_next = 1'b0;
        //Transition
        //Transition
        if (selector_temp == 8'b00000101) begin
          //Transition
          guard12 = 1'b1;
        end
        else if (selector_temp == 8'b00000110) begin
          //Transition
          guard13 = 1'b1;
        end
        else begin
          guard7 = 1'b1;
        end
      end
      else begin
        guard7 = 1'b1;
      end
    end
    if (guard14) begin
      f_sf_internal_predicateOutput = (selector_temp == 8'b00000101) || (selector_temp == 8'b00000110);
      if (f_sf_internal_predicateOutput) begin
        //Transition
        nCS1_reg_next = 1'b1;
        nCS2_reg_next = 1'b1;
        nCS3_reg_next = 1'b0;
        //Transition
        //Transition
        if (selector_temp == 8'b00000101) begin
          //Transition
          guard5 = 1'b1;
        end
        else if (selector_temp == 8'b00000110) begin
          //Transition
          guard6 = 1'b1;
        end
      end
    end
    if (guard13) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v3_2;
      //Entry 'toBsend_v3_2'
      //MATLAB Function 'simfcn1'

      for(bm1_8 = 1'b0; bm1_8 <= 3'b111; bm1_8 = bm1_8 + 1'b1) begin
        t_20[bm1_8] = v3_2[bm1_8] != 1'b0;
        tmp_8 = {7'b0, t_20[bm1_8]};
        j_8 = 32'sd7 - bm1_8;
        b_cont_bits_8[j_8] = tmp_8;
      end
      for(t_8 = 1'b0; t_8 <= 3'b111; t_8 = t_8 + 1'b1) begin
        cont_bits_next[t_8] = b_cont_bits_8[t_8];
      end

    end
    if (guard12) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v3_1;
      //Entry 'toBsend_v3_1'
      //MATLAB Function 'simfcn1'

      for(bm1_6 = 1'b0; bm1_6 <= 3'b111; bm1_6 = bm1_6 + 1'b1) begin
        t_21[bm1_6] = v3_1[bm1_6] != 1'b0;
        tmp_6 = {7'b0, t_21[bm1_6]};
        j_6 = 32'sd7 - bm1_6;
        b_cont_bits_6[j_6] = tmp_6;
      end
      for(t_9 = 1'b0; t_9 <= 3'b111; t_9 = t_9 + 1'b1) begin
        cont_bits_next[t_9] = b_cont_bits_6[t_9];
      end

    end
    if (guard11) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v2_2;
      //Entry 'toBsend_v2_2'
      //MATLAB Function 'simfcn1'

      for(bm1_4 = 1'b0; bm1_4 <= 3'b111; bm1_4 = bm1_4 + 1'b1) begin
        t_22[bm1_4] = v2_2[bm1_4] != 1'b0;
        tmp_4 = {7'b0, t_22[bm1_4]};
        j_4 = 32'sd7 - bm1_4;
        b_cont_bits_4[j_4] = tmp_4;
      end
      for(t_10 = 1'b0; t_10 <= 3'b111; t_10 = t_10 + 1'b1) begin
        cont_bits_next[t_10] = b_cont_bits_4[t_10];
      end

    end
    if (guard10) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v2_1;
      //Entry 'toBsend_v2_1'
      //MATLAB Function 'simfcn1'

      for(bm1_2 = 1'b0; bm1_2 <= 3'b111; bm1_2 = bm1_2 + 1'b1) begin
        t_23[bm1_2] = v2_1[bm1_2] != 1'b0;
        tmp_2 = {7'b0, t_23[bm1_2]};
        j_2 = 32'sd7 - bm1_2;
        b_cont_bits_2[j_2] = tmp_2;
      end
      for(t_11 = 1'b0; t_11 <= 3'b111; t_11 = t_11 + 1'b1) begin
        cont_bits_next[t_11] = b_cont_bits_2[t_11];
      end

    end
    if (guard9) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v1_2;
      //Entry 'toBsend_v1_2'
      //MATLAB Function 'simfcn1'

      for(bm1_0 = 1'b0; bm1_0 <= 3'b111; bm1_0 = bm1_0 + 1'b1) begin
        t_24[bm1_0] = v1_2[bm1_0] != 1'b0;
        tmp_0 = {7'b0, t_24[bm1_0]};
        j_0 = 32'sd7 - bm1_0;
        b_cont_bits_0[j_0] = tmp_0;
      end
      for(t_12 = 1'b0; t_12 <= 3'b111; t_12 = t_12 + 1'b1) begin
        cont_bits_next[t_12] = b_cont_bits_0[t_12];
      end

    end
    if (guard8) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v1_1;
      //Entry 'toBsend_v1_1'
      //MATLAB Function 'simfcn1'

      for(bm1 = 1'b0; bm1 <= 3'b111; bm1 = bm1 + 1'b1) begin
        t_25[bm1] = v1_1[bm1] != 1'b0;
        tmp = {7'b0, t_25[bm1]};
        j = 32'sd7 - bm1;
        b_cont_bits[j] = tmp;
      end
      for(t_13 = 1'b0; t_13 <= 3'b111; t_13 = t_13 + 1'b1) begin
        cont_bits_next[t_13] = b_cont_bits[t_13];
      end

    end
    if (guard7) begin
      SDI_reg_next = 1'b0;
      SCK_reg_next = 1'b0;
      nCS1_reg_next = 1'b1;
      nCS2_reg_next = 1'b1;
      nCS3_reg_next = 1'b1;
    end
    if (guard6) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v3_2;
      //Entry 'toBsend_v3_2'
      //MATLAB Function 'simfcn1'

      for(bm1_10 = 1'b0; bm1_10 <= 3'b111; bm1_10 = bm1_10 + 1'b1) begin
        t_26[bm1_10] = v3_2[bm1_10] != 1'b0;
        tmp_10 = {7'b0, t_26[bm1_10]};
        j_10 = 32'sd7 - bm1_10;
        b_cont_bits_10[j_10] = tmp_10;
      end
      for(t_14 = 1'b0; t_14 <= 3'b111; t_14 = t_14 + 1'b1) begin
        cont_bits_next[t_14] = b_cont_bits_10[t_14];
      end

    end
    if (guard5) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v3_1;
      //Entry 'toBsend_v3_1'
      //MATLAB Function 'simfcn1'

      for(bm1_9 = 1'b0; bm1_9 <= 3'b111; bm1_9 = bm1_9 + 1'b1) begin
        t_27[bm1_9] = v3_1[bm1_9] != 1'b0;
        tmp_9 = {7'b0, t_27[bm1_9]};
        j_9 = 32'sd7 - bm1_9;
        b_cont_bits_9[j_9] = tmp_9;
      end
      for(t_15 = 1'b0; t_15 <= 3'b111; t_15 = t_15 + 1'b1) begin
        cont_bits_next[t_15] = b_cont_bits_9[t_15];
      end

    end
    if (guard4) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v2_2;
      //Entry 'toBsend_v2_2'
      //MATLAB Function 'simfcn1'

      for(bm1_7 = 1'b0; bm1_7 <= 3'b111; bm1_7 = bm1_7 + 1'b1) begin
        t_28[bm1_7] = v2_2[bm1_7] != 1'b0;
        tmp_7 = {7'b0, t_28[bm1_7]};
        j_7 = 32'sd7 - bm1_7;
        b_cont_bits_7[j_7] = tmp_7;
      end
      for(t_16 = 1'b0; t_16 <= 3'b111; t_16 = t_16 + 1'b1) begin
        cont_bits_next[t_16] = b_cont_bits_7[t_16];
      end

    end
    if (guard3) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v2_1;
      //Entry 'toBsend_v2_1'
      //MATLAB Function 'simfcn1'

      for(bm1_5 = 1'b0; bm1_5 <= 3'b111; bm1_5 = bm1_5 + 1'b1) begin
        t_29[bm1_5] = v2_1[bm1_5] != 1'b0;
        tmp_5 = {7'b0, t_29[bm1_5]};
        j_5 = 32'sd7 - bm1_5;
        b_cont_bits_5[j_5] = tmp_5;
      end
      for(t_17 = 1'b0; t_17 <= 3'b111; t_17 = t_17 + 1'b1) begin
        cont_bits_next[t_17] = b_cont_bits_5[t_17];
      end

    end
    if (guard2) begin
      //Transition
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v1_2;
      //Entry 'toBsend_v1_2'
      //MATLAB Function 'simfcn1'

      for(bm1_3 = 1'b0; bm1_3 <= 3'b111; bm1_3 = bm1_3 + 1'b1) begin
        t_30[bm1_3] = v1_2[bm1_3] != 1'b0;
        tmp_3 = {7'b0, t_30[bm1_3]};
        j_3 = 32'sd7 - bm1_3;
        b_cont_bits_3[j_3] = tmp_3;
      end
      for(t_18 = 1'b0; t_18 <= 3'b111; t_18 = t_18 + 1'b1) begin
        cont_bits_next[t_18] = b_cont_bits_3[t_18];
      end

    end
    if (guard1) begin
      is_SPI_MNGR_next = state_type_is_SPI_MNGR_IN_toBsend_v1_1;
      //Entry 'toBsend_v1_1'
      //MATLAB Function 'simfcn1'

      for(bm1_1 = 1'b0; bm1_1 <= 3'b111; bm1_1 = bm1_1 + 1'b1) begin
        t_31[bm1_1] = v1_1[bm1_1] != 1'b0;
        tmp_1 = {7'b0, t_31[bm1_1]};
        j_1 = 32'sd7 - bm1_1;
        b_cont_bits_1[j_1] = tmp_1;
      end
      for(t_19 = 1'b0; t_19 <= 3'b111; t_19 = t_19 + 1'b1) begin
        cont_bits_next[t_19] = b_cont_bits_1[t_19];
      end

    end
    cnt_next = cnt_temp;
    selector_next = selector_temp;
  end

  assign SDI = SDI_reg_next;
  assign SCK = SCK_reg_next;
  assign nCS1 = nCS1_reg_next;
  assign nCS2 = nCS2_reg_next;
  assign nCS3 = nCS3_reg_next;
endmodule  // SPI_MNGR

