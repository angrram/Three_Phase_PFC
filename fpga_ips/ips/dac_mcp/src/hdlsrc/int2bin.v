// -------------------------------------------------------------
// 
// File Name: .\hdlsrc\int2bin_sdi\int2bin.v
// Created: 2024-09-18 12:34:23
// 
// Generated by MATLAB 23.2, HDL Coder 23.2, and Simulink 23.2
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: int2bin
// Source Path: int2bin_sdi/model_int2bin_sdi/in2bin/int2bin
// Hierarchy Level: 2
// Model version: 1.47
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module int2bin
          (clk,
           rst,
           enb_1_20_0,
           done,
           vx_x_cha,
           selector,
           en_sdi);

  // Default encoded enumeration values for type state_type_is_ON
  parameter state_type_is_ON_IN_NO_ACTIVE_CHILD = 3'd0, state_type_is_ON_b_IN_ON = 3'd1, state_type_is_ON_IN_selector = 3'd2, state_type_is_ON_IN_selector1 = 3'd3, state_type_is_ON_IN_selector2 = 3'd4;
  // Default encoded enumeration values for type state_type_is_int2bin
  parameter state_type_is_int2bin_IN_OFF = 1'd0, state_type_is_int2bin_IN_ON = 1'd1;

  input   clk;
  input   rst;
  input   enb_1_20_0;
  input   done;
  input   [7:0] vx_x_cha;  // uint8
  output  [7:0] selector;  // uint8
  output  en_sdi;


  reg [7:0] cnt;  // uint8
  reg [7:0] cnt_clk;  // uint8
  reg  is_int2bin;  // uint8
  reg [2:0] is_ON;  // uint8
  reg [7:0] selector_reg;  // uint8
  reg  en_sdi_reg;
  reg [7:0] cnt_next;  // uint8
  reg [7:0] cnt_clk_next;  // uint8
  reg  is_int2bin_next;  // enum type state_type_is_int2bin (2 enums)
  reg [2:0] is_ON_next;  // enum type state_type_is_ON (5 enums)
  reg [7:0] selector_reg_next;  // uint8
  reg  en_sdi_reg_next;
  reg  guard1;
  reg [7:0] cnt_temp;  // uint8
  reg [7:0] cnt_clk_temp;  // uint8
  reg [8:0] add_temp;  // ufix9
  reg [8:0] add_temp_0;  // ufix9
  reg [8:0] add_temp_1;  // ufix9
  reg [3:0] t_0;  // ufix4
  reg [8:0] t_1;  // ufix9
  reg [8:0] t_2;  // ufix9
  reg [8:0] t_3;  // ufix9


  always @(posedge clk)
    begin : int2bin_1_process
      if (rst == 1'b1) begin
        is_ON <= state_type_is_ON_IN_NO_ACTIVE_CHILD;
        en_sdi_reg <= 1'b0;
        cnt_clk <= 8'd0;
        //Entry: model_int2bin_sdi/in2bin/int2bin
        //Entry Internal: model_int2bin_sdi/in2bin/int2bin
        //Transition
        is_int2bin <= state_type_is_int2bin_IN_OFF;
        //Entry 'OFF'
        selector_reg <= 8'd7;
        cnt <= 8'd0;
      end
      else begin
        if (enb_1_20_0) begin
          cnt <= cnt_next;
          cnt_clk <= cnt_clk_next;
          is_int2bin <= is_int2bin_next;
          is_ON <= is_ON_next;
          selector_reg <= selector_reg_next;
          en_sdi_reg <= en_sdi_reg_next;
        end
      end
    end

  always @(cnt, cnt_clk, done, en_sdi_reg, is_ON, is_int2bin, selector_reg, vx_x_cha) begin
    guard1 = 1'b0;
    add_temp = 9'b000000000;
    add_temp_0 = 9'b000000000;
    add_temp_1 = 9'b000000000;
    t_3 = 9'b000000000;
    t_2 = 9'b000000000;
    t_1 = 9'b000000000;
    t_0 = 4'b0000;
    cnt_temp = cnt;
    cnt_clk_temp = cnt_clk;
    selector_reg_next = selector_reg;
    en_sdi_reg_next = en_sdi_reg;
    is_int2bin_next = is_int2bin;
    is_ON_next = is_ON;
    //Gateway: model_int2bin_sdi/in2bin/int2bin
    //During: model_int2bin_sdi/in2bin/int2bin
    case ( is_int2bin)
      state_type_is_int2bin_IN_OFF :
        begin
          //During 'OFF'
          //Transition
          is_int2bin_next = state_type_is_int2bin_IN_ON;
          //Entry 'ON'
          is_ON_next = state_type_is_ON_b_IN_ON;
          //Entry 'ON'
          cnt_temp = 8'd0;
          en_sdi_reg_next = 1'b0;
        end
      default :
        begin
          //case IN_ON:
          //During 'ON'
          guard1 = 1'b0;
          case ( is_ON)
            state_type_is_ON_b_IN_ON :
              begin
                //During 'ON'
                //Transition
                is_ON_next = state_type_is_ON_IN_selector;
                //Entry 'selector'
                t_2 = {1'b0, cnt};
                add_temp_0 = t_2 + 9'b000000001;
                if (add_temp_0[8] != 1'b0) begin
                  cnt_temp = 8'b11111111;
                end
                else begin
                  cnt_temp = add_temp_0[7:0];
                end
                selector_reg_next = cnt_temp;
              end
            state_type_is_ON_IN_selector :
              begin
                //During 'selector'
                //Transition
                is_ON_next = state_type_is_ON_IN_selector2;
                //Entry 'selector2'
                selector_reg_next = cnt;
              end
            state_type_is_ON_IN_selector1 :
              begin
                //During 'selector1'
                if (done) begin
                  //Transition
                  if (cnt < vx_x_cha) begin
                    //Transition
                    is_ON_next = state_type_is_ON_IN_selector;
                    //Entry 'selector'
                    t_3 = {1'b0, cnt};
                    add_temp_1 = t_3 + 9'b000000001;
                    if (add_temp_1[8] != 1'b0) begin
                      cnt_temp = 8'b11111111;
                    end
                    else begin
                      cnt_temp = add_temp_1[7:0];
                    end
                    selector_reg_next = cnt_temp;
                  end
                  else if (cnt >= vx_x_cha) begin
                    //Transition
                    is_ON_next = state_type_is_ON_b_IN_ON;
                    //Entry 'ON'
                    cnt_temp = 8'd0;
                    en_sdi_reg_next = 1'b0;
                  end
                  else begin
                    guard1 = 1'b1;
                  end
                end
                else begin
                  guard1 = 1'b1;
                end
              end
            default :
              begin
                //case IN_selector2:
                //During 'selector2'
                //Transition
                t_1 = {1'b0, cnt_clk};
                add_temp = t_1 + 9'b000000001;
                if (add_temp[8] != 1'b0) begin
                  cnt_clk_temp = 8'b11111111;
                end
                else begin
                  cnt_clk_temp = add_temp[7:0];
                end
                if (cnt_clk_temp >= 8'b00001011) begin
                  //Transition
                  is_ON_next = state_type_is_ON_IN_selector1;
                  //Entry 'selector1'
                  selector_reg_next = cnt;
                  en_sdi_reg_next = 1'b1;
                  cnt_clk_temp = 8'd0;
                end
                else begin
                  t_0 = cnt_clk_temp[3:0];
                  if (t_0 < 4'b1011) begin
                    //Transition
                    is_ON_next = state_type_is_ON_IN_selector2;
                    //Entry 'selector2'
                    selector_reg_next = cnt;
                  end
                  else begin
                    selector_reg_next = cnt;
                  end
                end
              end
          endcase
          if (guard1) begin
            selector_reg_next = cnt_temp;
            en_sdi_reg_next = 1'b1;
            cnt_clk_temp = 8'd0;
          end
        end
    endcase
    cnt_next = cnt_temp;
    cnt_clk_next = cnt_clk_temp;
  end

  assign selector = selector_reg_next;
  assign en_sdi = en_sdi_reg_next;


endmodule  // int2bin

